from pyArduinoML.model.NamedElement import NamedElement


class App(NamedElement):
    """
    Application built over bricks.

    """

    def __init__(self, name, bricks=(), states=(), modes=()):
        """
        Constructor.

        :param name: String, the name of the application
        :param bricks: List[Brick], bricks over which the application operates
        :param states: List[State], states of the application with the first one being the initial state
        :param modes: List[Mode], modes of the application with the first one being the initial mode
        :return:
        """
        NamedElement.__init__(self, name)
        self.bricks = bricks
        self.states = states
        self.modes = modes #check if modes is empty because generated code will be different 

    def __repr__(self):
        """
        External representation: Arduino program

        :return: String
        """

        rtr = "// generated by ArduinoML\n\n"
        rtr += "%s" % ("\n".join(map(lambda b: b.declare(), self.bricks)))
        rtr += "\n"
        if(len(self.modes) > 0):
            rtr += "\ntypedef void (*GeneralFunction) ();\nGeneralFunction current_state = NULL;\nString current_mode = \"\";\n"
        rtr += "\nvoid setup() {\n%s\n" % ("\n".join(map(lambda b: b.setup(), self.bricks)))
        if(len(self.modes) > 0):
            rtr += "\tcurrent_state = NULL;\n\tcurrent_mode = \"mode_%s\";\n\tmode_%s();\n" % (self.modes[0].name, self.modes[0].name)
        rtr += "}"
        rtr += "\n\nint state = LOW; int prev = HIGH;\nlong time = 0; long debounce = 200;\n\n"
        rtr += "%s" % ("\n".join(map(lambda m: m.setup(), self.modes)))
        rtr += "\n\n"
        rtr += "%s" % ("\n".join(map(lambda s: s.setup(), self.states)))
        rtr += "\nvoid loop() {\n\t state_%s(); \n}" % self.states[0].name #A Modifier avec les modes
        rtr += "\n\n\n------ TEST ------\n\n\n %s" % ("\n".join(map(lambda m: m.setupTransition(), self.modes)))
        return rtr
        
